{"version":3,"file":"optimize-worker-CTLlZoSs.js","sources":["../src/optimize/worker-enum.ts","../../../../oxipng/pkg/image_opt.js","../src/util/content-types.ts","../src/util/index.ts","../src/optimize/oxipng.ts","../../../../mozjpeg/enc/mozjpeg_enc.js","../../../../mozjpeg/enc/mozjpeg-color-space.ts","../src/optimize/mozjpeg.ts","../src/optimize/optimize-worker.ts"],"sourcesContent":["import { OptimizeInitOptions } from './optimize-options'\n\nexport interface WorkerFileData {\n  buffer?: ArrayBuffer\n  data?: ImageData\n}\n\nexport interface WorkerCommand {\n  init: OptimizeInitOptions\n  file?: WorkerFileData\n  options?: unknown\n}\n\nexport interface WorkerResult {\n  type: WorkerResultType\n  output?: unknown\n}\n\nexport enum WorkerResultType {\n  Complete = 'complete',\n  Error = 'error',\n}\n","let wasm;\n\nconst cachedTextDecoder =\n  typeof TextDecoder !== \"undefined\"\n    ? new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true })\n    : {\n        decode: () => {\n          throw Error(\"TextDecoder not available\");\n        },\n      };\n\nif (typeof TextDecoder !== \"undefined\") {\n  cachedTextDecoder.decode();\n}\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n  const ptr = malloc(arg.length * 1, 1) >>> 0;\n  getUint8Memory0().set(arg, ptr / 1);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n  return cachedInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n/**\n * @param {Uint8Array} data\n * @param {number} level\n * @param {boolean} interlace\n * @returns {Uint8Array}\n */\nexport function optimize(data, level, interlace) {\n  try {\n    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n    const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.optimize(retptr, ptr0, len0, level, interlace);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var v2 = getArrayU8FromWasm0(r0, r1).slice();\n    wasm.__wbindgen_free(r0, r1 * 1, 1);\n    return v2;\n  } finally {\n    wasm.__wbindgen_add_to_stack_pointer(16);\n  }\n}\n\nasync function __wbg_load(module, imports) {\n  if (typeof Response === \"function\" && module instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming === \"function\") {\n      try {\n        return await WebAssembly.instantiateStreaming(module, imports);\n      } catch (e) {\n        if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n          console.warn(\n            \"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\",\n            e\n          );\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const bytes = await module.arrayBuffer();\n    return await WebAssembly.instantiate(bytes, imports);\n  } else {\n    const instance = await WebAssembly.instantiate(module, imports);\n\n    if (instance instanceof WebAssembly.Instance) {\n      return { instance, module };\n    } else {\n      return instance;\n    }\n  }\n}\n\nfunction __wbg_get_imports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n\n  return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {}\n\nfunction __wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  __wbg_init.__wbindgen_wasm_module = module;\n  cachedInt32Memory0 = null;\n  cachedUint8Memory0 = null;\n\n  return wasm;\n}\n\nfunction initSync(module) {\n  if (wasm !== undefined) return wasm;\n\n  const imports = __wbg_get_imports();\n\n  __wbg_init_memory(imports);\n\n  if (!(module instanceof WebAssembly.Module)) {\n    module = new WebAssembly.Module(module);\n  }\n\n  const instance = new WebAssembly.Instance(module, imports);\n\n  return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n  if (wasm !== undefined) return wasm;\n\n  if (typeof input === \"undefined\") {\n    throw new Error(\"oxipng WASM missing\");\n  }\n  const imports = __wbg_get_imports();\n\n  if (\n    typeof input === \"string\" ||\n    (typeof Request === \"function\" && input instanceof Request) ||\n    (typeof URL === \"function\" && input instanceof URL)\n  ) {\n    input = fetch(input);\n  }\n\n  __wbg_init_memory(imports);\n\n  const { instance, module } = await __wbg_load(await input, imports);\n\n  return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","export enum AssetContentType {\n  Png = 'image/png',\n  Jpeg = 'image/jpeg',\n}\n\nexport const CONTENT_TYPES = Object.values(AssetContentType)\n","export * from './save-file'\nexport * from './validate-media'\nexport * from './content-types'\n\nexport const urlFromString = (str: string | undefined): URL | undefined => {\n  if (str) {\n    return new URL(str)\n  }\n  return undefined\n}\n","import init, { optimize, InitOutput } from '../../../../../oxipng/pkg/image_opt'\nimport { urlFromString } from '../util'\n\nexport interface IOxipngOptions {\n  level?: number\n  interlace?: boolean\n}\n\nlet oxipng: InitOutput\n\nexport const initOxipng = async (oxipngWasm: string | undefined) => {\n  if (!oxipng) {\n    oxipng = await init(urlFromString(oxipngWasm))\n  }\n}\n\nexport const optimizeOxipng = (buffer: ArrayBuffer, options?: IOxipngOptions) => {\n  const array = new Uint8Array(buffer)\n  const result = optimize(array, options?.level ?? 3, options?.interlace ?? false)\n  return result\n}\n","var Module = (function () {\n  var _scriptDir = import.meta.url;\n\n  return function (Module, binaryFile) {\n    Module = Module || {};\n\n    var Module = typeof Module !== \"undefined\" ? Module : {};\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    var moduleOverrides = {};\n    var key;\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = function (status, toThrow) {\n      throw toThrow;\n    };\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = true;\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n    var read_, readAsync, readBinary, setWindowTitle;\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        scriptDirectory = self.location.href;\n      } else if (typeof document !== \"undefined\" && document.currentScript) {\n        scriptDirectory = document.currentScript.src;\n      }\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.lastIndexOf(\"/\") + 1\n        );\n      } else {\n        scriptDirectory = \"\";\n      }\n      {\n        read_ = function (url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function (url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n        readAsync = function (url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = function () {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n      setWindowTitle = function (title) {\n        document.title = title;\n      };\n    } else {\n    }\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.warn.bind(console);\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    }\n    moduleOverrides = null;\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    var tempRet0 = 0;\n    var setTempRet0 = function (value) {\n      tempRet0 = value;\n    };\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    if (typeof WebAssembly !== \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n    var wasmMemory;\n    var ABORT = false;\n    var EXITSTATUS;\n    var UTF8Decoder = new TextDecoder(\"utf8\");\n    function UTF8ArrayToString(heap, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      return UTF8Decoder.decode(\n        heap.subarray\n          ? heap.subarray(idx, endPtr)\n          : new Uint8Array(heap.slice(idx, endPtr))\n      );\n    }\n    function UTF8ToString(ptr, maxBytesToRead) {\n      if (!ptr) return \"\";\n      var maxPtr = ptr + maxBytesToRead;\n      for (var end = ptr; !(end >= maxPtr) && HEAPU8[end]; ) ++end;\n      return UTF8Decoder.decode(HEAPU8.subarray(ptr, end));\n    }\n    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343) {\n          var u1 = str.charCodeAt(++i);\n          u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);\n        }\n        if (u <= 127) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 2047) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 192 | (u >> 6);\n          heap[outIdx++] = 128 | (u & 63);\n        } else if (u <= 65535) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 224 | (u >> 12);\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\n          heap[outIdx++] = 128 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 240 | (u >> 18);\n          heap[outIdx++] = 128 | ((u >> 12) & 63);\n          heap[outIdx++] = 128 | ((u >> 6) & 63);\n          heap[outIdx++] = 128 | (u & 63);\n        }\n      }\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    }\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    }\n    function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var u = str.charCodeAt(i);\n        if (u >= 55296 && u <= 57343)\n          u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);\n        if (u <= 127) ++len;\n        else if (u <= 2047) len += 2;\n        else if (u <= 65535) len += 3;\n        else len += 4;\n      }\n      return len;\n    }\n    var UTF16Decoder = new TextDecoder(\"utf-16le\");\n    function UTF16ToString(ptr, maxBytesToRead) {\n      var endPtr = ptr;\n      var idx = endPtr >> 1;\n      var maxIdx = idx + maxBytesToRead / 2;\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n      endPtr = idx << 1;\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      var str = \"\";\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n        var codeUnit = HEAP16[(ptr + i * 2) >> 1];\n        if (codeUnit == 0) break;\n        str += String.fromCharCode(codeUnit);\n      }\n      return str;\n    }\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2;\n      var startPtr = outPtr;\n      var numCharsToWrite =\n        maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      }\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n    function UTF32ToString(ptr, maxBytesToRead) {\n      var i = 0;\n      var str = \"\";\n      while (!(i >= maxBytesToRead / 4)) {\n        var utf32 = HEAP32[(ptr + i * 4) >> 2];\n        if (utf32 == 0) break;\n        ++i;\n        if (utf32 >= 65536) {\n          var ch = utf32 - 65536;\n          str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n      return str;\n    }\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 2147483647;\n      }\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit =\n            (65536 + ((codeUnit & 1023) << 10)) | (trailSurrogate & 1023);\n        }\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      }\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    }\n    function lengthBytesUTF32(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n        len += 4;\n      }\n      return len;\n    }\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      }\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - (x % multiple);\n      }\n      return x;\n    }\n    var buffer,\n      HEAP8,\n      HEAPU8,\n      HEAP16,\n      HEAPU16,\n      HEAP32,\n      HEAPU32,\n      HEAPF32,\n      HEAPF64;\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(buf);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(buf);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(buf);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(buf);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(buf);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(buf);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(buf);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(buf);\n    }\n    var INITIAL_MEMORY = Module[\"INITIAL_MEMORY\"] || 16777216;\n    var wasmTable;\n    var __ATPRERUN__ = [];\n    var __ATINIT__ = [];\n    var __ATPOSTRUN__ = [];\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\")\n          Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function exitRuntime() {\n      runtimeExited = true;\n    }\n    function postRun() {\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\")\n          Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null;\n    function addRunDependency(id) {\n      runDependencies++;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n    }\n    function removeRunDependency(id) {\n      runDependencies--;\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback();\n        }\n      }\n    }\n    Module[\"preloadedImages\"] = {};\n    Module[\"preloadedAudios\"] = {};\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n      what += \"\";\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what = \"abort(\" + what + \"). Build with -s ASSERTIONS=1 for more info.\";\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      throw e;\n    }\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n    function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    }\n    var wasmBinaryFile;\n    if (Module[\"locateFile\"]) {\n      if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = locateFile(wasmBinaryFile);\n      }\n    }\n    function getBinary(file) {\n      try {\n        if (file == wasmBinaryFile && wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n        if (readBinary) {\n          return readBinary(file);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n    function getBinaryPromise() {\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n        if (typeof fetch === \"function\") {\n          return fetch(wasmBinaryFile, { credentials: \"same-origin\" })\n            .then(function (response) {\n              if (!response[\"ok\"]) {\n                throw (\n                  \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\"\n                );\n              }\n              return response[\"arrayBuffer\"]();\n            })\n            .catch(function () {\n              return getBinary(wasmBinaryFile);\n            });\n        }\n      }\n      return Promise.resolve().then(function () {\n        return getBinary(wasmBinaryFile);\n      });\n    }\n    function createWasm(binaryFile) {\n      var info = { a: asmLibraryArg };\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module[\"asm\"] = exports;\n        wasmMemory = Module[\"asm\"][\"C\"];\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        wasmTable = Module[\"asm\"][\"I\"];\n        addOnInit(Module[\"asm\"][\"D\"]);\n        removeRunDependency(\"wasm-instantiate\");\n      }\n      addRunDependency(\"wasm-instantiate\");\n      function receiveInstantiationResult(result) {\n        receiveInstance(result[\"instance\"]);\n      }\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise()\n          .then(function (binary) {\n            var result = WebAssembly.instantiate(binary, info);\n            return result;\n          })\n          .then(receiver, function (reason) {\n            err(\"failed to asynchronously prepare wasm: \" + reason);\n            abort(reason);\n          });\n      }\n      function instantiateAsync(binaryFile) {\n        if (\n          !wasmBinary &&\n          typeof WebAssembly.instantiateStreaming === \"function\" &&\n          typeof fetch === \"function\"\n        ) {\n          return fetch(binaryFile, { credentials: \"same-origin\" }).then(\n            function (response) {\n              var result = WebAssembly.instantiateStreaming(response, info);\n              return result.then(receiveInstantiationResult, function (reason) {\n                err(\"wasm streaming compile failed: \" + reason);\n                err(\"falling back to ArrayBuffer instantiation\");\n                return instantiateArrayBuffer(receiveInstantiationResult);\n              });\n            }\n          );\n        } else {\n          return instantiateArrayBuffer(receiveInstantiationResult);\n        }\n      }\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          var exports = Module[\"instantiateWasm\"](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \" + e);\n          return false;\n        }\n      }\n      instantiateAsync(binaryFile).catch(readyPromiseReject);\n      return {};\n    }\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == \"function\") {\n          callback(Module);\n          continue;\n        }\n        var func = callback.func;\n        if (typeof func === \"number\") {\n          if (callback.arg === undefined) {\n            wasmTable.get(func)();\n          } else {\n            wasmTable.get(func)(callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n    var runtimeKeepaliveCounter = 0;\n    function keepRuntimeAlive() {\n      return noExitRuntime || runtimeKeepaliveCounter > 0;\n    }\n    function _atexit(func, arg) {}\n    function ___cxa_thread_atexit(a0, a1) {\n      return _atexit(a0, a1);\n    }\n    var structRegistrations = {};\n    function runDestructors(destructors) {\n      while (destructors.length) {\n        var ptr = destructors.pop();\n        var del = destructors.pop();\n        del(ptr);\n      }\n    }\n    function simpleReadValueFromPointer(pointer) {\n      return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n    }\n    var awaitingDependencies = {};\n    var registeredTypes = {};\n    var typeDependencies = {};\n    var char_0 = 48;\n    var char_9 = 57;\n    function makeLegalFunctionName(name) {\n      if (undefined === name) {\n        return \"_unknown\";\n      }\n      name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n      var f = name.charCodeAt(0);\n      if (f >= char_0 && f <= char_9) {\n        return \"_\" + name;\n      } else {\n        return name;\n      }\n    }\n    function createNamedFunction(name, body) {\n      name = makeLegalFunctionName(name);\n      return new Function(\n        \"body\",\n        \"return function \" +\n          name +\n          \"() {\\n\" +\n          '    \"use strict\";' +\n          \"    return body.apply(this, arguments);\\n\" +\n          \"};\\n\"\n      )(body);\n    }\n    function extendError(baseErrorType, errorName) {\n      var errorClass = createNamedFunction(errorName, function (message) {\n        this.name = errorName;\n        this.message = message;\n        var stack = new Error(message).stack;\n        if (stack !== undefined) {\n          this.stack =\n            this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n        }\n      });\n      errorClass.prototype = Object.create(baseErrorType.prototype);\n      errorClass.prototype.constructor = errorClass;\n      errorClass.prototype.toString = function () {\n        if (this.message === undefined) {\n          return this.name;\n        } else {\n          return this.name + \": \" + this.message;\n        }\n      };\n      return errorClass;\n    }\n    var InternalError = undefined;\n    function throwInternalError(message) {\n      throw new InternalError(message);\n    }\n    function whenDependentTypesAreResolved(\n      myTypes,\n      dependentTypes,\n      getTypeConverters\n    ) {\n      myTypes.forEach(function (type) {\n        typeDependencies[type] = dependentTypes;\n      });\n      function onComplete(typeConverters) {\n        var myTypeConverters = getTypeConverters(typeConverters);\n        if (myTypeConverters.length !== myTypes.length) {\n          throwInternalError(\"Mismatched type converter count\");\n        }\n        for (var i = 0; i < myTypes.length; ++i) {\n          registerType(myTypes[i], myTypeConverters[i]);\n        }\n      }\n      var typeConverters = new Array(dependentTypes.length);\n      var unregisteredTypes = [];\n      var registered = 0;\n      dependentTypes.forEach(function (dt, i) {\n        if (registeredTypes.hasOwnProperty(dt)) {\n          typeConverters[i] = registeredTypes[dt];\n        } else {\n          unregisteredTypes.push(dt);\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\n            awaitingDependencies[dt] = [];\n          }\n          awaitingDependencies[dt].push(function () {\n            typeConverters[i] = registeredTypes[dt];\n            ++registered;\n            if (registered === unregisteredTypes.length) {\n              onComplete(typeConverters);\n            }\n          });\n        }\n      });\n      if (0 === unregisteredTypes.length) {\n        onComplete(typeConverters);\n      }\n    }\n    function __embind_finalize_value_object(structType) {\n      var reg = structRegistrations[structType];\n      delete structRegistrations[structType];\n      var rawConstructor = reg.rawConstructor;\n      var rawDestructor = reg.rawDestructor;\n      var fieldRecords = reg.fields;\n      var fieldTypes = fieldRecords\n        .map(function (field) {\n          return field.getterReturnType;\n        })\n        .concat(\n          fieldRecords.map(function (field) {\n            return field.setterArgumentType;\n          })\n        );\n      whenDependentTypesAreResolved(\n        [structType],\n        fieldTypes,\n        function (fieldTypes) {\n          var fields = {};\n          fieldRecords.forEach(function (field, i) {\n            var fieldName = field.fieldName;\n            var getterReturnType = fieldTypes[i];\n            var getter = field.getter;\n            var getterContext = field.getterContext;\n            var setterArgumentType = fieldTypes[i + fieldRecords.length];\n            var setter = field.setter;\n            var setterContext = field.setterContext;\n            fields[fieldName] = {\n              read: function (ptr) {\n                return getterReturnType[\"fromWireType\"](\n                  getter(getterContext, ptr)\n                );\n              },\n              write: function (ptr, o) {\n                var destructors = [];\n                setter(\n                  setterContext,\n                  ptr,\n                  setterArgumentType[\"toWireType\"](destructors, o)\n                );\n                runDestructors(destructors);\n              },\n            };\n          });\n          return [\n            {\n              name: reg.name,\n              fromWireType: function (ptr) {\n                var rv = {};\n                for (var i in fields) {\n                  rv[i] = fields[i].read(ptr);\n                }\n                rawDestructor(ptr);\n                return rv;\n              },\n              toWireType: function (destructors, o) {\n                for (var fieldName in fields) {\n                  if (!(fieldName in o)) {\n                    throw new TypeError('Missing field:  \"' + fieldName + '\"');\n                  }\n                }\n                var ptr = rawConstructor();\n                for (fieldName in fields) {\n                  fields[fieldName].write(ptr, o[fieldName]);\n                }\n                if (destructors !== null) {\n                  destructors.push(rawDestructor, ptr);\n                }\n                return ptr;\n              },\n              argPackAdvance: 8,\n              readValueFromPointer: simpleReadValueFromPointer,\n              destructorFunction: rawDestructor,\n            },\n          ];\n        }\n      );\n    }\n    function __embind_register_bigint(\n      primitiveType,\n      name,\n      size,\n      minRange,\n      maxRange\n    ) {}\n    function getShiftFromSize(size) {\n      switch (size) {\n        case 1:\n          return 0;\n        case 2:\n          return 1;\n        case 4:\n          return 2;\n        case 8:\n          return 3;\n        default:\n          throw new TypeError(\"Unknown type size: \" + size);\n      }\n    }\n    function embind_init_charCodes() {\n      var codes = new Array(256);\n      for (var i = 0; i < 256; ++i) {\n        codes[i] = String.fromCharCode(i);\n      }\n      embind_charCodes = codes;\n    }\n    var embind_charCodes = undefined;\n    function readLatin1String(ptr) {\n      var ret = \"\";\n      var c = ptr;\n      while (HEAPU8[c]) {\n        ret += embind_charCodes[HEAPU8[c++]];\n      }\n      return ret;\n    }\n    var BindingError = undefined;\n    function throwBindingError(message) {\n      throw new BindingError(message);\n    }\n    function registerType(rawType, registeredInstance, options) {\n      options = options || {};\n      if (!(\"argPackAdvance\" in registeredInstance)) {\n        throw new TypeError(\n          \"registerType registeredInstance requires argPackAdvance\"\n        );\n      }\n      var name = registeredInstance.name;\n      if (!rawType) {\n        throwBindingError(\n          'type \"' + name + '\" must have a positive integer typeid pointer'\n        );\n      }\n      if (registeredTypes.hasOwnProperty(rawType)) {\n        if (options.ignoreDuplicateRegistrations) {\n          return;\n        } else {\n          throwBindingError(\"Cannot register type '\" + name + \"' twice\");\n        }\n      }\n      registeredTypes[rawType] = registeredInstance;\n      delete typeDependencies[rawType];\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\n        var callbacks = awaitingDependencies[rawType];\n        delete awaitingDependencies[rawType];\n        callbacks.forEach(function (cb) {\n          cb();\n        });\n      }\n    }\n    function __embind_register_bool(\n      rawType,\n      name,\n      size,\n      trueValue,\n      falseValue\n    ) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (wt) {\n          return !!wt;\n        },\n        toWireType: function (destructors, o) {\n          return o ? trueValue : falseValue;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: function (pointer) {\n          var heap;\n          if (size === 1) {\n            heap = HEAP8;\n          } else if (size === 2) {\n            heap = HEAP16;\n          } else if (size === 4) {\n            heap = HEAP32;\n          } else {\n            throw new TypeError(\"Unknown boolean type size: \" + name);\n          }\n          return this[\"fromWireType\"](heap[pointer >> shift]);\n        },\n        destructorFunction: null,\n      });\n    }\n    var emval_free_list = [];\n    var emval_handle_array = [\n      {},\n      { value: undefined },\n      { value: null },\n      { value: true },\n      { value: false },\n    ];\n    function __emval_decref(handle) {\n      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {\n        emval_handle_array[handle] = undefined;\n        emval_free_list.push(handle);\n      }\n    }\n    function count_emval_handles() {\n      var count = 0;\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          ++count;\n        }\n      }\n      return count;\n    }\n    function get_first_emval() {\n      for (var i = 5; i < emval_handle_array.length; ++i) {\n        if (emval_handle_array[i] !== undefined) {\n          return emval_handle_array[i];\n        }\n      }\n      return null;\n    }\n    function init_emval() {\n      Module[\"count_emval_handles\"] = count_emval_handles;\n      Module[\"get_first_emval\"] = get_first_emval;\n    }\n    function __emval_register(value) {\n      switch (value) {\n        case undefined: {\n          return 1;\n        }\n        case null: {\n          return 2;\n        }\n        case true: {\n          return 3;\n        }\n        case false: {\n          return 4;\n        }\n        default: {\n          var handle = emval_free_list.length\n            ? emval_free_list.pop()\n            : emval_handle_array.length;\n          emval_handle_array[handle] = { refcount: 1, value: value };\n          return handle;\n        }\n      }\n    }\n    function __embind_register_emval(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (handle) {\n          var rv = emval_handle_array[handle].value;\n          __emval_decref(handle);\n          return rv;\n        },\n        toWireType: function (destructors, value) {\n          return __emval_register(value);\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: null,\n      });\n    }\n    function _embind_repr(v) {\n      if (v === null) {\n        return \"null\";\n      }\n      var t = typeof v;\n      if (t === \"object\" || t === \"array\" || t === \"function\") {\n        return v.toString();\n      } else {\n        return \"\" + v;\n      }\n    }\n    function floatReadValueFromPointer(name, shift) {\n      switch (shift) {\n        case 2:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n          };\n        case 3:\n          return function (pointer) {\n            return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n          };\n        default:\n          throw new TypeError(\"Unknown float type: \" + name);\n      }\n    }\n    function __embind_register_float(rawType, name, size) {\n      var shift = getShiftFromSize(size);\n      name = readLatin1String(name);\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (value) {\n          return value;\n        },\n        toWireType: function (destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError(\n              'Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name\n            );\n          }\n          return value;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: floatReadValueFromPointer(name, shift),\n        destructorFunction: null,\n      });\n    }\n    function new_(constructor, argumentList) {\n      if (!(constructor instanceof Function)) {\n        throw new TypeError(\n          \"new_ called with constructor type \" +\n            typeof constructor +\n            \" which is not a function\"\n        );\n      }\n      var dummy = createNamedFunction(\n        constructor.name || \"unknownFunctionName\",\n        function () {}\n      );\n      dummy.prototype = constructor.prototype;\n      var obj = new dummy();\n      var r = constructor.apply(obj, argumentList);\n      return r instanceof Object ? r : obj;\n    }\n    function craftInvokerFunction(\n      humanName,\n      argTypes,\n      classType,\n      cppInvokerFunc,\n      cppTargetFunc\n    ) {\n      var argCount = argTypes.length;\n      if (argCount < 2) {\n        throwBindingError(\n          \"argTypes array size mismatch! Must at least get return value and 'this' types!\"\n        );\n      }\n      var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n      var needsDestructorStack = false;\n      for (var i = 1; i < argTypes.length; ++i) {\n        if (\n          argTypes[i] !== null &&\n          argTypes[i].destructorFunction === undefined\n        ) {\n          needsDestructorStack = true;\n          break;\n        }\n      }\n      var returns = argTypes[0].name !== \"void\";\n      var argsList = \"\";\n      var argsListWired = \"\";\n      for (var i = 0; i < argCount - 2; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n        argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n      }\n      var invokerFnBody =\n        \"return function \" +\n        makeLegalFunctionName(humanName) +\n        \"(\" +\n        argsList +\n        \") {\\n\" +\n        \"if (arguments.length !== \" +\n        (argCount - 2) +\n        \") {\\n\" +\n        \"throwBindingError('function \" +\n        humanName +\n        \" called with ' + arguments.length + ' arguments, expected \" +\n        (argCount - 2) +\n        \" args!');\\n\" +\n        \"}\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"var destructors = [];\\n\";\n      }\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n      var args1 = [\n        \"throwBindingError\",\n        \"invoker\",\n        \"fn\",\n        \"runDestructors\",\n        \"retType\",\n        \"classParam\",\n      ];\n      var args2 = [\n        throwBindingError,\n        cppInvokerFunc,\n        cppTargetFunc,\n        runDestructors,\n        argTypes[0],\n        argTypes[1],\n      ];\n      if (isClassMethodFunc) {\n        invokerFnBody +=\n          \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n      }\n      for (var i = 0; i < argCount - 2; ++i) {\n        invokerFnBody +=\n          \"var arg\" +\n          i +\n          \"Wired = argType\" +\n          i +\n          \".toWireType(\" +\n          dtorStack +\n          \", arg\" +\n          i +\n          \"); // \" +\n          argTypes[i + 2].name +\n          \"\\n\";\n        args1.push(\"argType\" + i);\n        args2.push(argTypes[i + 2]);\n      }\n      if (isClassMethodFunc) {\n        argsListWired =\n          \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n      }\n      invokerFnBody +=\n        (returns ? \"var rv = \" : \"\") +\n        \"invoker(fn\" +\n        (argsListWired.length > 0 ? \", \" : \"\") +\n        argsListWired +\n        \");\\n\";\n      if (needsDestructorStack) {\n        invokerFnBody += \"runDestructors(destructors);\\n\";\n      } else {\n        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {\n          var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n          if (argTypes[i].destructorFunction !== null) {\n            invokerFnBody +=\n              paramName +\n              \"_dtor(\" +\n              paramName +\n              \"); // \" +\n              argTypes[i].name +\n              \"\\n\";\n            args1.push(paramName + \"_dtor\");\n            args2.push(argTypes[i].destructorFunction);\n          }\n        }\n      }\n      if (returns) {\n        invokerFnBody +=\n          \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n      } else {\n      }\n      invokerFnBody += \"}\\n\";\n      args1.push(invokerFnBody);\n      var invokerFunction = new_(Function, args1).apply(null, args2);\n      return invokerFunction;\n    }\n    function ensureOverloadTable(proto, methodName, humanName) {\n      if (undefined === proto[methodName].overloadTable) {\n        var prevFunc = proto[methodName];\n        proto[methodName] = function () {\n          if (\n            !proto[methodName].overloadTable.hasOwnProperty(arguments.length)\n          ) {\n            throwBindingError(\n              \"Function '\" +\n                humanName +\n                \"' called with an invalid number of arguments (\" +\n                arguments.length +\n                \") - expects one of (\" +\n                proto[methodName].overloadTable +\n                \")!\"\n            );\n          }\n          return proto[methodName].overloadTable[arguments.length].apply(\n            this,\n            arguments\n          );\n        };\n        proto[methodName].overloadTable = [];\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n      }\n    }\n    function exposePublicSymbol(name, value, numArguments) {\n      if (Module.hasOwnProperty(name)) {\n        if (\n          undefined === numArguments ||\n          (undefined !== Module[name].overloadTable &&\n            undefined !== Module[name].overloadTable[numArguments])\n        ) {\n          throwBindingError(\"Cannot register public name '\" + name + \"' twice\");\n        }\n        ensureOverloadTable(Module, name, name);\n        if (Module.hasOwnProperty(numArguments)) {\n          throwBindingError(\n            \"Cannot register multiple overloads of a function with the same number of arguments (\" +\n              numArguments +\n              \")!\"\n          );\n        }\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        if (undefined !== numArguments) {\n          Module[name].numArguments = numArguments;\n        }\n      }\n    }\n    function heap32VectorToArray(count, firstElement) {\n      var array = [];\n      for (var i = 0; i < count; i++) {\n        array.push(HEAP32[(firstElement >> 2) + i]);\n      }\n      return array;\n    }\n    function replacePublicSymbol(name, value, numArguments) {\n      if (!Module.hasOwnProperty(name)) {\n        throwInternalError(\"Replacing nonexistant public symbol\");\n      }\n      if (\n        undefined !== Module[name].overloadTable &&\n        undefined !== numArguments\n      ) {\n        Module[name].overloadTable[numArguments] = value;\n      } else {\n        Module[name] = value;\n        Module[name].argCount = numArguments;\n      }\n    }\n    function dynCallLegacy(sig, ptr, args) {\n      var f = Module[\"dynCall_\" + sig];\n      return args && args.length\n        ? f.apply(null, [ptr].concat(args))\n        : f.call(null, ptr);\n    }\n    function dynCall(sig, ptr, args) {\n      if (sig.includes(\"j\")) {\n        return dynCallLegacy(sig, ptr, args);\n      }\n      return wasmTable.get(ptr).apply(null, args);\n    }\n    function getDynCaller(sig, ptr) {\n      var argCache = [];\n      return function () {\n        argCache.length = arguments.length;\n        for (var i = 0; i < arguments.length; i++) {\n          argCache[i] = arguments[i];\n        }\n        return dynCall(sig, ptr, argCache);\n      };\n    }\n    function embind__requireFunction(signature, rawFunction) {\n      signature = readLatin1String(signature);\n      function makeDynCaller() {\n        if (signature.includes(\"j\")) {\n          return getDynCaller(signature, rawFunction);\n        }\n        return wasmTable.get(rawFunction);\n      }\n      var fp = makeDynCaller();\n      if (typeof fp !== \"function\") {\n        throwBindingError(\n          \"unknown function pointer with signature \" +\n            signature +\n            \": \" +\n            rawFunction\n        );\n      }\n      return fp;\n    }\n    var UnboundTypeError = undefined;\n    function getTypeName(type) {\n      var ptr = ___getTypeName(type);\n      var rv = readLatin1String(ptr);\n      _free(ptr);\n      return rv;\n    }\n    function throwUnboundTypeError(message, types) {\n      var unboundTypes = [];\n      var seen = {};\n      function visit(type) {\n        if (seen[type]) {\n          return;\n        }\n        if (registeredTypes[type]) {\n          return;\n        }\n        if (typeDependencies[type]) {\n          typeDependencies[type].forEach(visit);\n          return;\n        }\n        unboundTypes.push(type);\n        seen[type] = true;\n      }\n      types.forEach(visit);\n      throw new UnboundTypeError(\n        message + \": \" + unboundTypes.map(getTypeName).join([\", \"])\n      );\n    }\n    function __embind_register_function(\n      name,\n      argCount,\n      rawArgTypesAddr,\n      signature,\n      rawInvoker,\n      fn\n    ) {\n      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n      name = readLatin1String(name);\n      rawInvoker = embind__requireFunction(signature, rawInvoker);\n      exposePublicSymbol(\n        name,\n        function () {\n          throwUnboundTypeError(\n            \"Cannot call \" + name + \" due to unbound types\",\n            argTypes\n          );\n        },\n        argCount - 1\n      );\n      whenDependentTypesAreResolved([], argTypes, function (argTypes) {\n        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));\n        replacePublicSymbol(\n          name,\n          craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn),\n          argCount - 1\n        );\n        return [];\n      });\n    }\n    function integerReadValueFromPointer(name, shift, signed) {\n      switch (shift) {\n        case 0:\n          return signed\n            ? function readS8FromPointer(pointer) {\n                return HEAP8[pointer];\n              }\n            : function readU8FromPointer(pointer) {\n                return HEAPU8[pointer];\n              };\n        case 1:\n          return signed\n            ? function readS16FromPointer(pointer) {\n                return HEAP16[pointer >> 1];\n              }\n            : function readU16FromPointer(pointer) {\n                return HEAPU16[pointer >> 1];\n              };\n        case 2:\n          return signed\n            ? function readS32FromPointer(pointer) {\n                return HEAP32[pointer >> 2];\n              }\n            : function readU32FromPointer(pointer) {\n                return HEAPU32[pointer >> 2];\n              };\n        default:\n          throw new TypeError(\"Unknown integer type: \" + name);\n      }\n    }\n    function __embind_register_integer(\n      primitiveType,\n      name,\n      size,\n      minRange,\n      maxRange\n    ) {\n      name = readLatin1String(name);\n      if (maxRange === -1) {\n        maxRange = 4294967295;\n      }\n      var shift = getShiftFromSize(size);\n      var fromWireType = function (value) {\n        return value;\n      };\n      if (minRange === 0) {\n        var bitshift = 32 - 8 * size;\n        fromWireType = function (value) {\n          return (value << bitshift) >>> bitshift;\n        };\n      }\n      var isUnsignedType = name.includes(\"unsigned\");\n      registerType(primitiveType, {\n        name: name,\n        fromWireType: fromWireType,\n        toWireType: function (destructors, value) {\n          if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n            throw new TypeError(\n              'Cannot convert \"' + _embind_repr(value) + '\" to ' + this.name\n            );\n          }\n          if (value < minRange || value > maxRange) {\n            throw new TypeError(\n              'Passing a number \"' +\n                _embind_repr(value) +\n                '\" from JS side to C/C++ side to an argument of type \"' +\n                name +\n                '\", which is outside the valid range [' +\n                minRange +\n                \", \" +\n                maxRange +\n                \"]!\"\n            );\n          }\n          return isUnsignedType ? value >>> 0 : value | 0;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: integerReadValueFromPointer(\n          name,\n          shift,\n          minRange !== 0\n        ),\n        destructorFunction: null,\n      });\n    }\n    function __embind_register_memory_view(rawType, dataTypeIndex, name) {\n      var typeMapping = [\n        Int8Array,\n        Uint8Array,\n        Int16Array,\n        Uint16Array,\n        Int32Array,\n        Uint32Array,\n        Float32Array,\n        Float64Array,\n      ];\n      var TA = typeMapping[dataTypeIndex];\n      function decodeMemoryView(handle) {\n        handle = handle >> 2;\n        var heap = HEAPU32;\n        var size = heap[handle];\n        var data = heap[handle + 1];\n        return new TA(buffer, data, size);\n      }\n      name = readLatin1String(name);\n      registerType(\n        rawType,\n        {\n          name: name,\n          fromWireType: decodeMemoryView,\n          argPackAdvance: 8,\n          readValueFromPointer: decodeMemoryView,\n        },\n        { ignoreDuplicateRegistrations: true }\n      );\n    }\n    function __embind_register_std_string(rawType, name) {\n      name = readLatin1String(name);\n      var stdStringIsUTF8 = name === \"std::string\";\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (value) {\n          var length = HEAPU32[value >> 2];\n          var str;\n          if (stdStringIsUTF8) {\n            var decodeStartPtr = value + 4;\n            for (var i = 0; i <= length; ++i) {\n              var currentBytePtr = value + 4 + i;\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\n                var maxRead = currentBytePtr - decodeStartPtr;\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                if (str === undefined) {\n                  str = stringSegment;\n                } else {\n                  str += String.fromCharCode(0);\n                  str += stringSegment;\n                }\n                decodeStartPtr = currentBytePtr + 1;\n              }\n            }\n          } else {\n            var a = new Array(length);\n            for (var i = 0; i < length; ++i) {\n              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);\n            }\n            str = a.join(\"\");\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: function (destructors, value) {\n          if (value instanceof ArrayBuffer) {\n            value = new Uint8Array(value);\n          }\n          var getLength;\n          var valueIsOfTypeString = typeof value === \"string\";\n          if (\n            !(\n              valueIsOfTypeString ||\n              value instanceof Uint8Array ||\n              value instanceof Uint8ClampedArray ||\n              value instanceof Int8Array\n            )\n          ) {\n            throwBindingError(\"Cannot pass non-string to std::string\");\n          }\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            getLength = function () {\n              return lengthBytesUTF8(value);\n            };\n          } else {\n            getLength = function () {\n              return value.length;\n            };\n          }\n          var length = getLength();\n          var ptr = _malloc(4 + length + 1);\n          HEAPU32[ptr >> 2] = length;\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\n            stringToUTF8(value, ptr + 4, length + 1);\n          } else {\n            if (valueIsOfTypeString) {\n              for (var i = 0; i < length; ++i) {\n                var charCode = value.charCodeAt(i);\n                if (charCode > 255) {\n                  _free(ptr);\n                  throwBindingError(\n                    \"String has UTF-16 code units that do not fit in 8 bits\"\n                  );\n                }\n                HEAPU8[ptr + 4 + i] = charCode;\n              }\n            } else {\n              for (var i = 0; i < length; ++i) {\n                HEAPU8[ptr + 4 + i] = value[i];\n              }\n            }\n          }\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: function (ptr) {\n          _free(ptr);\n        },\n      });\n    }\n    function __embind_register_std_wstring(rawType, charSize, name) {\n      name = readLatin1String(name);\n      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n      if (charSize === 2) {\n        decodeString = UTF16ToString;\n        encodeString = stringToUTF16;\n        lengthBytesUTF = lengthBytesUTF16;\n        getHeap = function () {\n          return HEAPU16;\n        };\n        shift = 1;\n      } else if (charSize === 4) {\n        decodeString = UTF32ToString;\n        encodeString = stringToUTF32;\n        lengthBytesUTF = lengthBytesUTF32;\n        getHeap = function () {\n          return HEAPU32;\n        };\n        shift = 2;\n      }\n      registerType(rawType, {\n        name: name,\n        fromWireType: function (value) {\n          var length = HEAPU32[value >> 2];\n          var HEAP = getHeap();\n          var str;\n          var decodeStartPtr = value + 4;\n          for (var i = 0; i <= length; ++i) {\n            var currentBytePtr = value + 4 + i * charSize;\n            if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n              if (str === undefined) {\n                str = stringSegment;\n              } else {\n                str += String.fromCharCode(0);\n                str += stringSegment;\n              }\n              decodeStartPtr = currentBytePtr + charSize;\n            }\n          }\n          _free(value);\n          return str;\n        },\n        toWireType: function (destructors, value) {\n          if (!(typeof value === \"string\")) {\n            throwBindingError(\n              \"Cannot pass non-string to C++ string type \" + name\n            );\n          }\n          var length = lengthBytesUTF(value);\n          var ptr = _malloc(4 + length + charSize);\n          HEAPU32[ptr >> 2] = length >> shift;\n          encodeString(value, ptr + 4, length + charSize);\n          if (destructors !== null) {\n            destructors.push(_free, ptr);\n          }\n          return ptr;\n        },\n        argPackAdvance: 8,\n        readValueFromPointer: simpleReadValueFromPointer,\n        destructorFunction: function (ptr) {\n          _free(ptr);\n        },\n      });\n    }\n    function __embind_register_value_object(\n      rawType,\n      name,\n      constructorSignature,\n      rawConstructor,\n      destructorSignature,\n      rawDestructor\n    ) {\n      structRegistrations[rawType] = {\n        name: readLatin1String(name),\n        rawConstructor: embind__requireFunction(\n          constructorSignature,\n          rawConstructor\n        ),\n        rawDestructor: embind__requireFunction(\n          destructorSignature,\n          rawDestructor\n        ),\n        fields: [],\n      };\n    }\n    function __embind_register_value_object_field(\n      structType,\n      fieldName,\n      getterReturnType,\n      getterSignature,\n      getter,\n      getterContext,\n      setterArgumentType,\n      setterSignature,\n      setter,\n      setterContext\n    ) {\n      structRegistrations[structType].fields.push({\n        fieldName: readLatin1String(fieldName),\n        getterReturnType: getterReturnType,\n        getter: embind__requireFunction(getterSignature, getter),\n        getterContext: getterContext,\n        setterArgumentType: setterArgumentType,\n        setter: embind__requireFunction(setterSignature, setter),\n        setterContext: setterContext,\n      });\n    }\n    function __embind_register_void(rawType, name) {\n      name = readLatin1String(name);\n      registerType(rawType, {\n        isVoid: true,\n        name: name,\n        argPackAdvance: 0,\n        fromWireType: function () {\n          return undefined;\n        },\n        toWireType: function (destructors, o) {\n          return undefined;\n        },\n      });\n    }\n    var emval_symbols = {};\n    function getStringOrSymbol(address) {\n      var symbol = emval_symbols[address];\n      if (symbol === undefined) {\n        return readLatin1String(address);\n      } else {\n        return symbol;\n      }\n    }\n    function emval_get_global() {\n      if (typeof globalThis === \"object\") {\n        return globalThis;\n      }\n      return (function () {\n        return Function;\n      })()(\"return this\")();\n    }\n    function __emval_get_global(name) {\n      if (name === 0) {\n        return __emval_register(emval_get_global());\n      } else {\n        name = getStringOrSymbol(name);\n        return __emval_register(emval_get_global()[name]);\n      }\n    }\n    function __emval_incref(handle) {\n      if (handle > 4) {\n        emval_handle_array[handle].refcount += 1;\n      }\n    }\n    function requireRegisteredType(rawType, humanName) {\n      var impl = registeredTypes[rawType];\n      if (undefined === impl) {\n        throwBindingError(\n          humanName + \" has unknown type \" + getTypeName(rawType)\n        );\n      }\n      return impl;\n    }\n    function craftEmvalAllocator(argCount) {\n      var argsList = \"\";\n      for (var i = 0; i < argCount; ++i) {\n        argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n      }\n      var functionBody =\n        \"return function emval_allocator_\" +\n        argCount +\n        \"(constructor, argTypes, args) {\\n\";\n      for (var i = 0; i < argCount; ++i) {\n        functionBody +=\n          \"var argType\" +\n          i +\n          \" = requireRegisteredType(Module['HEAP32'][(argTypes >>> 2) + \" +\n          i +\n          '], \"parameter ' +\n          i +\n          '\");\\n' +\n          \"var arg\" +\n          i +\n          \" = argType\" +\n          i +\n          \".readValueFromPointer(args);\\n\" +\n          \"args += argType\" +\n          i +\n          \"['argPackAdvance'];\\n\";\n      }\n      functionBody +=\n        \"var obj = new constructor(\" +\n        argsList +\n        \");\\n\" +\n        \"return __emval_register(obj);\\n\" +\n        \"}\\n\";\n      return new Function(\n        \"requireRegisteredType\",\n        \"Module\",\n        \"__emval_register\",\n        functionBody\n      )(requireRegisteredType, Module, __emval_register);\n    }\n    var emval_newers = {};\n    function requireHandle(handle) {\n      if (!handle) {\n        throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n      }\n      return emval_handle_array[handle].value;\n    }\n    function __emval_new(handle, argCount, argTypes, args) {\n      handle = requireHandle(handle);\n      var newer = emval_newers[argCount];\n      if (!newer) {\n        newer = craftEmvalAllocator(argCount);\n        emval_newers[argCount] = newer;\n      }\n      return newer(handle, argTypes, args);\n    }\n    function _abort() {\n      abort();\n    }\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n    function emscripten_realloc_buffer(size) {\n      try {\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16);\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1;\n      } catch (e) {}\n    }\n    function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      requestedSize = requestedSize >>> 0;\n      var maxHeapSize = 2147483648;\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);\n        overGrownHeapSize = Math.min(\n          overGrownHeapSize,\n          requestedSize + 100663296\n        );\n        var newSize = Math.min(\n          maxHeapSize,\n          alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)\n        );\n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var ENV = {};\n    function getExecutableName() {\n      return thisProgram || \"./this.program\";\n    }\n    function getEnvStrings() {\n      if (!getEnvStrings.strings) {\n        var lang =\n          (\n            (typeof navigator === \"object\" &&\n              navigator.languages &&\n              navigator.languages[0]) ||\n            \"C\"\n          ).replace(\"-\", \"_\") + \".UTF-8\";\n        var env = {\n          USER: \"web_user\",\n          LOGNAME: \"web_user\",\n          PATH: \"/\",\n          PWD: \"/\",\n          HOME: \"/home/web_user\",\n          LANG: lang,\n          _: getExecutableName(),\n        };\n        for (var x in ENV) {\n          env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(x + \"=\" + env[x]);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    }\n    var SYSCALLS = {\n      mappings: {},\n      buffers: [null, [], []],\n      printChar: function (stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },\n      varargs: undefined,\n      get: function () {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];\n        return ret;\n      },\n      getStr: function (ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n      get64: function (low, high) {\n        return low;\n      },\n    };\n    function _environ_get(__environ, environ_buf) {\n      var bufSize = 0;\n      getEnvStrings().forEach(function (string, i) {\n        var ptr = environ_buf + bufSize;\n        HEAP32[(__environ + i * 4) >> 2] = ptr;\n        writeAsciiToMemory(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    }\n    function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = getEnvStrings();\n      HEAP32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(function (string) {\n        bufSize += string.length + 1;\n      });\n      HEAP32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    }\n    function _exit(status) {\n      exit(status);\n    }\n    function _fd_close(fd) {\n      return 0;\n    }\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(iov + i * 8) >> 2];\n        var len = HEAP32[(iov + (i * 8 + 4)) >> 2];\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n        }\n        num += len;\n      }\n      HEAP32[pnum >> 2] = num;\n      return 0;\n    }\n    function _setTempRet0(val) {\n      setTempRet0(val);\n    }\n    InternalError = Module[\"InternalError\"] = extendError(\n      Error,\n      \"InternalError\"\n    );\n    embind_init_charCodes();\n    BindingError = Module[\"BindingError\"] = extendError(Error, \"BindingError\");\n    init_emval();\n    UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(\n      Error,\n      \"UnboundTypeError\"\n    );\n    var asmLibraryArg = {\n      B: ___cxa_thread_atexit,\n      l: __embind_finalize_value_object,\n      p: __embind_register_bigint,\n      y: __embind_register_bool,\n      x: __embind_register_emval,\n      i: __embind_register_float,\n      f: __embind_register_function,\n      c: __embind_register_integer,\n      b: __embind_register_memory_view,\n      j: __embind_register_std_string,\n      e: __embind_register_std_wstring,\n      m: __embind_register_value_object,\n      a: __embind_register_value_object_field,\n      z: __embind_register_void,\n      g: __emval_decref,\n      u: __emval_get_global,\n      k: __emval_incref,\n      n: __emval_new,\n      h: _abort,\n      r: _emscripten_memcpy_big,\n      d: _emscripten_resize_heap,\n      s: _environ_get,\n      t: _environ_sizes_get,\n      A: _exit,\n      w: _fd_close,\n      o: _fd_seek,\n      v: _fd_write,\n      q: _setTempRet0,\n    };\n    var asm = createWasm(binaryFile);\n    var ___wasm_call_ctors = (Module[\"___wasm_call_ctors\"] = function () {\n      return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] =\n        Module[\"asm\"][\"D\"]).apply(null, arguments);\n    });\n    var _malloc = (Module[\"_malloc\"] = function () {\n      return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"E\"]).apply(\n        null,\n        arguments\n      );\n    });\n    var _free = (Module[\"_free\"] = function () {\n      return (_free = Module[\"_free\"] = Module[\"asm\"][\"F\"]).apply(\n        null,\n        arguments\n      );\n    });\n    var ___getTypeName = (Module[\"___getTypeName\"] = function () {\n      return (___getTypeName = Module[\"___getTypeName\"] =\n        Module[\"asm\"][\"G\"]).apply(null, arguments);\n    });\n    var ___embind_register_native_and_builtin_types = (Module[\n      \"___embind_register_native_and_builtin_types\"\n    ] = function () {\n      return (___embind_register_native_and_builtin_types = Module[\n        \"___embind_register_native_and_builtin_types\"\n      ] =\n        Module[\"asm\"][\"H\"]).apply(null, arguments);\n    });\n    var dynCall_jiji = (Module[\"dynCall_jiji\"] = function () {\n      return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"J\"]).apply(\n        null,\n        arguments\n      );\n    });\n    var calledRun;\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n    dependenciesFulfilled = function runCaller() {\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller;\n    };\n    function run(args) {\n      args = args || arguments_;\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n        postRun();\n      }\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    Module[\"run\"] = run;\n    function exit(status, implicit) {\n      EXITSTATUS = status;\n      if (implicit && keepRuntimeAlive() && status === 0) {\n        return;\n      }\n      if (keepRuntimeAlive()) {\n      } else {\n        exitRuntime();\n        if (Module[\"onExit\"]) Module[\"onExit\"](status);\n        ABORT = true;\n      }\n      quit_(status, new ExitStatus(status));\n    }\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\")\n        Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n    run();\n\n    return Module.ready;\n  };\n})();\nexport default Module;\n","export const enum MozJpegColorSpace {\n  GRAYSCALE = 1,\n  RGB,\n  YCbCr,\n}\n","import init, {\n  MozJPEGModule,\n  EncodeOptions,\n} from '../../../../../mozjpeg/enc/mozjpeg_enc'\nimport { MozJpegColorSpace } from '../../../../../mozjpeg/enc/mozjpeg-color-space'\nimport { urlFromString } from '../util'\n\nexport type IMozjpegOptions = EncodeOptions\n\nexport const defaultMozjpegOptions: EncodeOptions = {\n  quality: 75,\n  baseline: false,\n  arithmetic: false,\n  progressive: true,\n  optimize_coding: true,\n  smoothing: 0,\n  color_space: MozJpegColorSpace.YCbCr,\n  quant_table: 3,\n  trellis_multipass: false,\n  trellis_opt_zero: false,\n  trellis_opt_table: false,\n  trellis_loops: 1,\n  auto_subsample: true,\n  chroma_subsample: 2,\n  separate_chroma_quality: false,\n  chroma_quality: 75,\n}\n\nlet mozjpeg: MozJPEGModule\n\nexport const initMozjpeg = async (mozjpegWasm: string | undefined) => {\n  if (!mozjpeg) {\n    mozjpeg = await init({}, urlFromString(mozjpegWasm))\n  }\n}\n\nexport const optimizeMozjpeg = (image: ImageData, options: IMozjpegOptions) => {\n  const result = mozjpeg.encode(image.data, image.width, image.height, options)\n  return result\n}\n","import { WorkerCommand, WorkerFileData, WorkerResultType } from './worker-enum'\nimport { IOxipngOptions, initOxipng, optimizeOxipng } from './oxipng'\nimport { AssetContentType } from '../util'\nimport { IMozjpegOptions, initMozjpeg, optimizeMozjpeg } from './mozjpeg'\n\nself.onmessage = async (e: MessageEvent<WorkerCommand>) => {\n  const { file, init, options } = (e.data ?? {}) as WorkerCommand\n  if (!file) {\n    return\n  }\n  const { buffer, data } = file\n  switch (init.assetType) {\n    case AssetContentType.Png:\n      try {\n        if (!buffer) {\n          self.postMessage({ type: WorkerResultType.Error, output: 'Invalid PNG data' })\n          return\n        }\n        await initOxipng(init.oxipngWasm)\n        const opts = options as IOxipngOptions | undefined\n        const result = optimizeOxipng(buffer, opts)\n        self.postMessage({ type: WorkerResultType.Complete, output: result })\n      } catch (e) {\n        self.postMessage({ type: WorkerResultType.Error, output: e })\n      }\n      break\n    case AssetContentType.Jpeg:\n      try {\n        if (!data) {\n          self.postMessage({ type: WorkerResultType.Error, output: 'Invalid JPG data' })\n          return\n        }\n        await initMozjpeg(init.mozjpegWasm)\n        const opts = options as IMozjpegOptions\n        const result = optimizeMozjpeg(data, opts)\n        self.postMessage({ type: WorkerResultType.Complete, output: result })\n      } catch (e) {\n        self.postMessage({ type: WorkerResultType.Error, output: e })\n      }\n      break\n    default:\n      console.log('Error: unknown worker command', e.data)\n      self.postMessage({ type: WorkerResultType.Error, output: 'Unknown command' })\n  }\n}\n\nexport {}\n"],"names":["WorkerResultType","wasm","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","Error","cachedUint8Memory0","getUint8Memory0","byteLength","Uint8Array","memory","buffer","WASM_VECTOR_LEN","cachedInt32Memory0","getInt32Memory0","Int32Array","optimize","data","level","interlace","retptr","__wbindgen_add_to_stack_pointer","ptr0","arg","malloc","ptr","length","set","__wbindgen_malloc","len0","r0","r1","v2","len","subarray","slice","__wbindgen_free","__wbg_get_imports","imports","wbg","__wbindgen_throw","arg0","arg1","async","__wbg_init","input","Request","URL","fetch","instance","module","Response","WebAssembly","instantiateStreaming","e","headers","get","console","warn","bytes","arrayBuffer","instantiate","Instance","__wbg_load","exports","__wbindgen_wasm_module","AssetContentType","Object","values","urlFromString","str","oxipng","_scriptDir","Module","url","binaryFile","readyPromiseResolve","readyPromiseReject","Promise","resolve","reject","key","moduleOverrides","hasOwnProperty","readBinary","thisProgram","quit_","status","toThrow","ENVIRONMENT_IS_WORKER","scriptDirectory","self","location","href","indexOf","substr","lastIndexOf","xhr","XMLHttpRequest","open","responseType","send","response","wasmBinary","out","log","bind","err","wasmMemory","noExitRuntime","abort","ABORT","UTF8Decoder","UTF8ToString","maxBytesToRead","maxPtr","end","HEAPU8","HEAP8","HEAP16","HEAPU16","HEAP32","HEAPU32","HEAPF32","HEAPF64","wasmTable","UTF16Decoder","UTF16ToString","endPtr","idx","maxIdx","stringToUTF16","outPtr","maxBytesToWrite","undefined","startPtr","numCharsToWrite","i","codeUnit","charCodeAt","lengthBytesUTF16","UTF32ToString","utf32","ch","String","fromCharCode","stringToUTF32","lengthBytesUTF32","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array","wasmBinaryFile","path","__ATPRERUN__","__ATINIT__","__ATPOSTRUN__","runDependencies","dependenciesFulfilled","what","RuntimeError","getBinary","file","callRuntimeCallbacks","callbacks","callback","shift","func","startsWith","runtimeKeepaliveCounter","structRegistrations","runDestructors","destructors","pop","simpleReadValueFromPointer","pointer","this","awaitingDependencies","registeredTypes","typeDependencies","char_0","char_9","makeLegalFunctionName","name","f","replace","createNamedFunction","body","Function","extendError","baseErrorType","errorName","errorClass","message","stack","toString","prototype","create","constructor","InternalError","throwInternalError","whenDependentTypesAreResolved","myTypes","dependentTypes","getTypeConverters","onComplete","typeConverters","myTypeConverters","registerType","forEach","type","Array","unregisteredTypes","registered","dt","push","getShiftFromSize","size","TypeError","embind_charCodes","readLatin1String","ret","c","BindingError","throwBindingError","rawType","registeredInstance","options","ignoreDuplicateRegistrations","cb","emval_free_list","emval_handle_array","value","__emval_decref","handle","refcount","count_emval_handles","count","get_first_emval","__emval_register","_embind_repr","v","t","floatReadValueFromPointer","craftInvokerFunction","humanName","argTypes","classType","cppInvokerFunc","cppTargetFunc","argCount","isClassMethodFunc","needsDestructorStack","destructorFunction","returns","argsList","argsListWired","invokerFnBody","dtorStack","args1","args2","paramName","argumentList","dummy","obj","r","apply","exposePublicSymbol","numArguments","overloadTable","proto","methodName","prevFunc","arguments","dynCall","sig","args","includes","concat","call","embind__requireFunction","signature","rawFunction","argCache","fp","UnboundTypeError","getTypeName","___getTypeName","rv","_free","integerReadValueFromPointer","signed","emval_symbols","emval_get_global","globalThis","requireRegisteredType","impl","emval_newers","emscripten_realloc_buffer","grow","ENV","getEnvStrings","strings","env","USER","LOGNAME","PATH","PWD","HOME","LANG","navigator","languages","_","x","SYSCALLS","mappings","buffers","printChar","stream","curr","heap","endIdx","varargs","getStr","get64","low","high","codes","asmLibraryArg","B","a0","a1","l","structType","reg","rawConstructor","rawDestructor","fieldRecords","fields","map","field","getterReturnType","setterArgumentType","fieldTypes","fieldName","getter","getterContext","setter","setterContext","read","write","o","fromWireType","toWireType","argPackAdvance","readValueFromPointer","p","primitiveType","minRange","maxRange","y","trueValue","falseValue","wt","rawArgTypesAddr","rawInvoker","fn","firstElement","array","types","unboundTypes","seen","visit","join","invokerArgsArray","bitshift","isUnsignedType","b","dataTypeIndex","TA","decodeMemoryView","j","stdStringIsUTF8","decodeStartPtr","currentBytePtr","stringSegment","a","getLength","ArrayBuffer","valueIsOfTypeString","Uint8ClampedArray","u","_malloc","outIdx","charCode","charSize","decodeString","encodeString","getHeap","lengthBytesUTF","HEAP","m","constructorSignature","destructorSignature","getterSignature","setterSignature","z","isVoid","g","symbol","address","k","n","newer","functionBody","h","dest","src","num","copyWithin","d","requestedSize","multiple","oldSize","maxHeapSize","cutDown","overGrownHeapSize","Math","min","max","s","__environ","environ_buf","bufSize","string","dontAddNull","penviron_count","penviron_buf_size","A","implicit","ExitStatus","w","fd","offset_low","offset_high","whence","newOffset","iov","iovcnt","pnum","q","val","info","receiveInstance","unshift","id","receiveInstantiationResult","result","instantiateArrayBuffer","receiver","credentials","then","catch","binary","reason","calledRun","run","doRun","postRun","preRun","setTimeout","runCaller","ready","MozJpegColorSpace","MozJpegColorSpace2","mozjpeg","YCbCr","onmessage","init","assetType","Png","postMessage","output","oxipngWasm","Complete","Jpeg","mozjpegWasm","image","encode","width","height","optimizeMozjpeg"],"mappings":"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"}